## DTO

DTO(Data Transfer Object)는 데이터 전송 객체이다.

보통 클라이언트와 서버 간 데이터 교환을 위해 사용되나

분리되어 있는 각 계층간에도 데이터 교환을 위해 사용한다.

---
### 1. DTO는 분리되어야 한다.

다음 그림을 보면 각 계층별로 오고가는 DTO가 분리되어 있다.

<img src="./image/dtoImage1.png"></img>

하나의 API를 처리할 때, 왜 하나의 DTO로 오고가면 안될까?

왜, 여러개의 DTO를 각각 만들어서 해당 계층 변환 및 데이터 전송만 진행할까?


- 현재 회사의 레거시 소스코드는 빌드된 공통 소스코드를 받아 **메가 DTO**를 통해 요청을 받고 반환해주며 사용하고 있다.
    - 그래서 많은 필드들을 가진 DTO는 300 ~ 400개도 지니고 있다.
    
        - (심지어 이것도 공통 DTO , entity 상속받음) 

    - 이는 어디서 데이터가 변환되어야 하는지 알 수가 없다.

        - Controller에서 validation check 하는 필드는 무엇인가? 

        - Service에서 어떤 필드들을 사용해 로직을 진행하는가?

        - Repository에서만 사용하는 Entity는 다른 계층에서 오고 갈 때 필요없다.

    - **SOLID 원칙**을 대부분 위반한다.
        
        - 하나의 책임을 지니지 않고 여러 책임을 지닌다. 결합도가 증가한다. (SRP 원칙 위배)

        - 데이터를 계층 어디서든 변경이 가능하여 무결성이 보장되지 않는다. 이는 변경에 대해 열려있다. (OCP 원칙 위배)

        - 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야 한다. 이는 다른 계층의 데이터를 포함한다. Interface는 아니지만, 원칙에 위배될 수 있다. (ISP 원칙 위배)

        - 추상화에 의존해야 하나, 결합된 모든 클래스가 DTO에 의존한다. (DIP 원칙 위배)
    - 
    
그렇기에 각 계층 별로 DTO를 나눈다.

--- 

### 2. DTO는 데이터를 저장하고 값을 꺼내올 수 있는 책임이 있어야 한다.

많은 개발자들은 getter, setter, builder 어노테이션만을 사용한다. 다른 메서드 만드는 것을 꺼리곤 한다.

그리고 데이터에 대한 검증은 Service에서 진행한다?

따지고 보면 어노테이션도 메서드를 자동 생성해주는 기능이다.(디컴파일시 확인 가능)

클라이언트로부터 다음과 같은 데이터를 받아온다고 가정한다.

```Java
@Getter
public class RequestDto {

    private String Date;
    private String nowDate;

}

```

